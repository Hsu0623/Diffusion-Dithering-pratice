# -*- coding: utf-8 -*-
"""
Created on Wed Oct 23 21:16:35 2019

@author: User
"""

import cv2
import numpy as np
origin = cv2.imread("D:\\hw_picture\\lena.jpg",0)
rs, cs = origin.shape

ClassMatrix = np.array(
 [[204,  0,  5, 33, 51, 59, 23,118, 54, 69, 40,160,169,110,168,188],
 [  3,  6, 22, 36, 60, 50, 74,115,140, 82,147,164,171,142,220,214],
 [ 14,  7, 42, 16, 63, 52, 94, 56,133,152,158,177,179,208,222,  1],
 [ 15, 26, 43, 75, 79, 84,148, 81,139,136,166,102,217,219,226,  4],
 [ 17, 39, 72, 92,103,108,150,135,157,193,190,100,223,225,227, 13],
 [ 28,111, 99, 87,116,131,155,112,183,196,181,224,232,228, 12, 21],
 [ 47,120, 91,105,125,132,172,180,184,205,175,233,245,  8, 20, 41],
 [ 76, 65,129,137,165,145,178,194,206,170,229,244,246, 19, 24, 49],
 [ 80, 73,106,138,176,182,174,197,218,235,242,249,247, 18, 48, 68],
 [101,107,134,153,185,163,202,173,231,241,248,253, 44, 88, 70, 45],
 [123,141,149, 61,195,200,221,234,240,243,254, 38, 46, 77,104,109],
 [ 85, 96,156,130,203,215,230,250,251,252,255, 53, 62, 93, 86,117],
 [151,167,189,207,201,216,236,239, 25, 31, 34,113, 83, 95,124,114],
 [144,146,191,209,213,237,238, 29, 32, 55, 64, 97,126, 78,128,159],
 [187,192,198,212,  9, 10, 30, 35, 58, 67, 90, 71,122,127,154,161],
 [199,210,211,  2, 11, 27, 37, 57, 66, 89, 98,121,119,143,162,186]])
ErrorArr = np.array(
[[0.38459,1,0.38459],
[1,0,1],
[0.38459,1,0.38459]])
Matrix_t = np.zeros((18,18))  #這在下面才會用到
Matrix_t[1:17,1:17] = ClassMatrix

for i in range(0, rs, 16):    #先把原圖分成一塊一塊地來處理
    for j in range(0,cs,16):  #分成(512/16)*(512/16)塊
        s = 0        #s是用來記錄要找到順序幾，因為它的處理順序事著ClassMatrix來處理的
        halftone = np.zeros((18,18))   #每一塊雖是16*16,但是會有邊界問題，所以要做個18*18大小的
        halftone[1:17,1:17] = origin[i:i+16,j:j+16]  #周遭一圈都是0
        while s <= 255:
            a,b = np.where(ClassMatrix == s)  #np.where是用來尋找s在classMatrix的哪裡
            a = int(a)    #在第幾row。
            b = int(b)   #在第幾colum， 但是因為ClassMatrix大小是16*16，而要處理的是18*18
            old =  halftone[1+a][1+b] #所以a,b要加1才是真正的位置
            E = old - (255*(old//128))  #算誤差值
            temp_im = np.zeros((3,3))   #temp_im是個3*3array
            temp_im[0:3,0:3] = halftone[a:a+3,b:b+3]  #它是以要處理的那點為中心的9個像素
            test = np.zeros((3,3))  #
            test = Matrix_t[a:a+3,b:b+3]  #上面有先定義Matrix_t了

            ave = ErrorArr[test > s]  #test是用來看該點周遭有哪個點已經先處理過了
            weightsum =ave.sum()   #將該點周遭尚未處理過的像素值都加起來
            temp_im[test>s] += ErrorArr[test>s]*(E/weightsum)  #開始擴散是誤差到周遭尚未處理過的點
            temp_im[temp_im < 0] = 0;   
            temp_im[temp_im > 255] = 255;
            halftone[a:a+3,b:b+3] = temp_im[0:3,0:3]    #把temp_im貼回halftone去
            halftone[1+a][1+b] = (old//128)*255 #若該點像素值>=128則為255,反之則為0
            s += 1   #處理完該點，繼續處理下一個點 
        origin[i:i+16,j:j+16] = halftone[1:17,1:17]  #當這一塊處理完後貼回原圖，再去處理下一塊
        
cv2.imwrite("D:\\hw_picture\\lena_dot_diffusion.jpg",origin)
cv2.imshow("image", origin)
cv2.waitKey(0)
cv2.destroyAllWindows()
